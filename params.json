{"name":"View models","tagline":"Rails Presenters with a little bit of decoration - add an R to your MVC","body":"# View Models [![Build Status](https://secure.travis-ci.org/beatrichartz/view_models.png)](http://travis-ci.org/beatrichartz/view_models) [![CodeClimate](https://codeclimate.com/github/beatrichartz/view_models.png)](https://codeclimate.com/github/beatrichartz/view_models)\r\n\r\nA representer solution for Rails 3 and 4 inspired by Florian Hankes View Models for Rails 2 (http://florianhanke.com/view_models). For older versions of Rails please use versions up to 3. You may find view models useful (or not). Fact: They will keep code out of your views. Because view models do not like code in your view.\r\n\r\n## Installing View Models\r\n\r\nAdd this to your gemfile\r\n\r\n<pre><code>gem \"view_models\",   \"~> 4.0\"\r\n</code></pre>\r\n\r\nAnd this to your application.rb: (It adds the app folder to the autoload paths, which is necessary for the view models to load)\r\n<pre><code>config.autoload_paths += %W(#{config.root}/app)\r\n</code></pre>\r\n\r\nCreate a directory \"view_models\" in your app folder, and you're good to go.\r\n<pre><code>mkdir ./app/view_models\r\n</code></pre>\r\n\r\n## TODOs\r\n\r\nWhat you can look forward to in future versions of this gem:\r\n- Bootstrapping for easier installation\r\n\r\n## Basic Usage\r\n\r\nLet's say you have a model User (with a first and a last name and an address in the database):\r\n\r\n<pre><code>class User < ActiveRecord::Base\r\n  \r\n  has_many :posts\r\n  \r\nend\r\n</code></pre>\r\n\r\nWrite a corresponding view model user.rb in your view_models folder\r\n\r\n<pre><code>class ViewModels::User < ViewModels::Base\r\n  \r\n  # model readers make model methods accessible on the view model object\r\n  #\r\n  model_reader :first_name, :last_name, :street, :street_number, :zip_code, :city\r\n  \r\n  # Write helper methods which benefit from model readers\r\n  #\r\n  def name\r\n    [first_name, last_name].join ' '\r\n  end\r\n  \r\n  # Access the model by using «model»\r\n  #\r\n  def creation_time\r\n    time_ago_in_words model.created_at\r\n  end\r\n  \r\nend\r\n</code></pre>\r\n\r\nIn your view, call the view_model for a model by using «view_model_for»\r\n\r\n<pre><code>- view_model = view_model_for(@user)\r\n%h2= view_model.name\r\n%h2= view_model.creation_time\r\n</code></pre>\r\n\r\nAll beautiful, you may think, but...\r\n\r\n## Why View Models? (aka «The Problem»)\r\n\r\nEver felt like putting something like this in your views (example in haml)?\r\n\r\n<pre><code>#user\r\n  .name= [@user.first_name, @user.last_name].join ' '\r\n  .address= [@user.street, @user.street_number, @user.zip_code, @user.city].join ' '\r\n</code></pre>\r\n\r\nWell, that may feel good if you're in a hurry. Soon there comes the time when you use this code in more than one place. Time to build a helper:\r\n\r\n<pre><code>module UserHelper\r\n  def user_name user\r\n    [user.first_name, user.last_name].join ' '\r\n  end\r\n\r\n  def user_address user\r\n    [user.street, user.street_number, user.zip_code, user.city].join ' '\r\n  end\r\nend\r\n\r\n#user\r\n  .name= user_name @user\r\n  .address= user_address @user\r\n</code></pre>\r\n\r\nIt may be a lot cleaner, but something just does not feel right. Right, but what? Well, for instance, you have to namespace all your methods with «user» so your methods don't get messy. Second, you have to include the helper either in every context you use it, or even in the whole app. If only you had a polymorphic object to represent your models in the views...\r\n\r\n### Meet View Models (aka «The Solution»)\r\n\r\nView models are pretty, because they represent your models in your views. They look good in every context, and therefore make you look good, too. Take our example from before:\r\n\r\n<pre><code>class ViewModels::User < ViewModels::Base\r\n\r\n  model_reader :first_name, :last_name, :street, :street_number, :zip_code, :city\r\n  \r\n  def name\r\n    [first_name, last_name].join ' '\r\n  end\r\n\r\n  def address\r\n    [street, street_number, zip_code, city].join ' '\r\n  end\r\n  \r\nend\r\n</code></pre>\r\n\r\nAnd your view will look like this:\r\n\r\n<pre><code>- user_view_model = view_model_for(@user)\r\n#user\r\n  .name= user_view_model.name\r\n  .address= user_view_model.address\r\n</code></pre>\r\n\r\nNo helper inclusion needed, no further noise involved. In fact, you can make it even prettier: What if you needed that partial with the user name and address somewhere else in your code?\r\n\r\n### Meet View Models render_as Method\r\n\r\nView models feature template rendering: You can render any partial in your views, following your views directory tree structure: A view_model variable will automatically be included as a local variable in your partial if you render it with view models:\r\n\r\nLet's say you have the user model from before, and the following partial written for the view model to render named \"info\":\r\n\r\n<pre><code>#user\r\n  .name= view_model.name\r\n  .address= view_model.address\r\n</code></pre>\r\n\r\nNow everything you have to do to render that partial is:\r\n\r\n<pre><code>= view_model_for(@user).render_as :info\r\n</code></pre>\r\n\r\nView models feature hierarchical template rendering. That means, if you have a parent view model which has an identical partial already installed, you do not need to copy identical code just to render the same template. The view model will lookup its inheritance chain and Rails template paths to find the suitable partial. Which brings us to another great feature:\r\n\r\n### View Models Can Haz Inheritance\r\n\r\nEver tried to do inheritance in Rails helpers? Right. View Models, on the other side, love inheritance. They do not need arguments to display a formatted creation time for all your models. Consider the following:\r\n\r\n#### The View Model Way\r\n\r\nYou can generate a view model tree structure with a view model for your whole app for your other view models to inherit from. The polymorphic class matching of the view models ignores the missing class YourApp candidly.\r\n\r\n<pre><code>class ViewModels::YourApp < ViewModels::Base\r\n\r\n  def creation_time\r\n    time_ago_in_words model.created_at\r\n  end\r\n\r\nend\r\n\r\nclass ViewModels::User < ViewModels::YourApp\r\nend\r\n</code></pre>\r\n\r\nIn your view:\r\n\r\n<pre><code>= view_model_for(@user).creation_time\r\n</code></pre>\r\n\r\n#### The Helper Way\r\n\r\nImagine how to do this in a helper ? Well, better go ahead and use time_ago_in_words everywhere.\r\n\r\n## Testing View Models\r\n\r\nTesting View Models is easy. You can use the view models initializer instead of the view_model_for mapping (example in rspec with factory girl):\r\n\r\n<pre><code>describe \"ViewModels::User\" do\r\n  let(:user) { build_stubbed(:user) }\r\n  subject { ViewModels::User.new(user, @controller) } # @controller may be nil or the controller\r\n  \r\n  describe \"model_readers\"\r\n    .. there you go\r\n  end\r\nend\r\n</code></pre>\r\n\r\n## Further Reads\r\n\r\n[RubyGems](http://rubygems.org/gems/view_models)\r\n[Bug Tracker](http://github.com/beatrichartz/view_models/issues)\r\n[Source](http://github.com/beatrichartz/view_models)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}